---
showOutline: false
---

# FAQ

## Is this just token voting?
No.

Cobuild stake weight is used to route treasury flows, not to pass proposals.
You’re continuously expressing “fund this path more than that path”, and the router executes it.

## Why no baseline flow?
Because baseline funding turns into “set-and-forget”.
Cobuild makes funding an explicit, continuously maintained signal:
no stake → no stream.

## Can I stop funding a budget I no longer believe in?
Yes. You can set your **stake weight** on that budget to 0, which reduces that budget’s weight in the global allocation and immediately reduces its stream.

However:
- points stop accruing on that budget once you remove stake
- you can reallocate that stake to another budget immediately
- you cannot withdraw `$COBUILD` from the Goal until Goal resolution

## Do I lose principal if a budget fails?
Not by default.

Policy:
- budget fails without invariant breach → **no rewards** for that budget, but stake can be reallocated to other budgets
- invariant breach / proven misconduct → slashing can occur

## What can I actually lose?
- opportunity cost of locked capital
- rewards from unsuccessful budgets
- principal only if slashed for proven misconduct or invariant breach

## What stops people from proposing "easy" budgets that don't help?
Two forces:
1) rewards are gated on Goal success (local farming doesn't pay if the overall goal fails)
2) other stakers can refuse to direct weight there (stake is the quality filter)

## What stops a wealthy staker from routing funds to themselves?
A staker's allocation power is proportional to their `$COBUILD` stake. Mitigations include:
- allocation power is proportional to `$COBUILD` staked, not extracting from others
- enforceable invariants that restrict payouts or conflicts of interest
- competition from other stakers (counter-allocation)
- objective success conditions and dispute mechanisms
See [Incentives & threat model](/dao/incentives) for details.

## What stops last-minute reward sniping?
Rewards are computed using stake-time (how long your stake has been on a budget), not instantaneous weight.

## Why have activationThreshold and runwayCap?
`activationThreshold` (aka `minBudget`) prevents a budget from starting to spend with too little runway.  
`runwayCap` (aka `maxBudget`) prevents overfunding and reduces the need for destabilizing stake withdrawals just to stop inflow.

## Why do child mechanisms require budget-level stake?
So directing funds to a mechanism is conditional on backing the budget strategy.
This reduces perverse incentives where someone tries to farm inside a budget they don't actually support.

## Can a budget spend funds and still fail?
Yes. Spending is not success. If a budget fails its success condition, stakers earn no rewards even if funds were spent.

## Do direct deposits to a budget affect rewards?
They can, but the policy must be explicit. Recommended default: direct deposits count toward balances (activation/runway), but do **not** increase RewardEscrow or reward weights unless routed through the Goal.

## What stops a budget from setting a very short execution window and draining fast?
`maxRatePerStakeUnit` caps how fast any amount of stake can pull funds. Implementations can also add a hard execution outflow cap if needed.

## What happens to reward points if the Goal fails?
Default: they become non-redeemable (0).

This is the core alignment:
rewards only exist if the Goal succeeds.

## Do you support transferable reward claims?
Yes (recommended).

Reward points can be implemented as a transferable claim token.
This helps stakers get liquidity even though rewards are gated.

## Who sets parameters?
The Goal creator sets parameters at creation time (immutable for that Goal).

## What oracle do you use?
Default: UMA Optimistic Oracle.
The protocol can support a pluggable oracle interface if you need alternatives later.
